# 事务
- 构成单一逻辑工作单元的 `操作集合` 称为事务(transaction)。

## 事务概念
- 事务是访问并可能更新各种数据项的一个程序执行单元(unit)。

- 事务用形如 begin transaction和 end transaction界定。

- 这些步骤集合必须作为单一的，不可分割的单元出现。

- 事务的ACID
    1. 原子性(atomicity)
        - 事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映。
    
    2. 一致性(consistency)
        - 隔离执行事务时保持数据库的一致性。
        - 一致性是指数据库的状态在事务执行前是一致的，事务执行后也是一致的。包括数据的完整性约束，也包括业务逻辑上的一致性。
        - 例如银行账户的转账，5个账户共有500块，无论你怎么转账，事务执行完都必须保持这个状态。
    
    3. 隔离性(isolation)
        - 尽管事务之间并发执行，但是事务执行时不会受到其他事务的影响，就跟只有一个事务执行一样。

    4. 持久性(durability)
        - 事务完成后对数据库的改变是永久的。
    
---

## 简单的事务模型
- 采用一个由几个账户一个访问和更新账户的事务集合构成的简单的银行引用来说明事务。

- read(X)，从数据库中读取X。
- write(X)，把X写到数据库中。

- 假设由如下事务T，从账户A转账50给账户B。假设A有1000，B有2000
```
read(A);
A = A - 50;
write(A);
read(B);
B = B + 50;
write(B);
```

1. 一致性：事务的执行不改变AB之和。

2. 原子性：假设在执行事务T时系统出现故障，导致T执行失败。故障发生在write(A)之后，write(B)之前。
    - 这时候A中只剩950，而B有2000。我们注意到AB之和被改变了。

    - 这种状态我们称为 `不一致状态`(inconsistent state)。

    - 我们必须保证这种状态在数据库系统中是不可见的。当然该状态在事务执行中是不可避免的，但是我们要保证不一致状态只出现在事务执行过程中，执行完毕后还是一致状态。

- 保持原子性的思路如下：
    - 对于事务要执行写操作的数据项，数据库系统在一个称为日志的文件中记录其旧值。如果事务失败，就从日志中回复旧值。
    - 这项工作由称作 `恢复系统` (recovery system)的一个数据库组件处理。

3. 持久性：一旦事务成功执行，系统就必须保证任何故障不会引起数据丢失。
    1. 事务做的更新在事务结束前写入磁盘。
    2. 事务已执行的更新信息写到磁盘上，保证数据库故障后能重新恢复。

4. 隔离性：事务之间应该不互相影响。每个事务都仿佛单独执行一样。

----
## 事务原子性和持久性

- 事务失败称为 `中止` (aborted)。

- 中止事务对数据库所做过的改变必须被撤销。

- 中止事务的改变被撤销，我们就说事务 `已回滚` (rolled back)。

- 典型的方法是维护一个日志(log)。每个事务对DB的修改都会先记录到日志中。一旦中止就根据日志回滚。

- 成功执行的事务称为 `已提交`(committed)。

- 一旦事务提交，我们就无法通过中止来撤销更改。要恢复更改唯一方法是执行一个 `补偿事务`(compensating transaction)。 例如一个事务是+20，补偿事务就应该-20。 这个工作由用户完成。

- 事务的状态：
    - 活动的(active)：初始状态，事务执行时的状态。

    - 部分提交的(partially committed)：最后一条语句执行后

    - 失败的(failed)：发现正常的执行不能继续后

    - 中止的(aborted)：事务回滚并且数据库恢复到开始前的状态后

    - 提交的(committed)：成功完成后

- 如果事务是中止的或提交的，称为 `已经结束的` (terminated)

- 中止状态的事务，系统有两种选择：
    1. 重启(restart)事务。当且仅当引起事务中止的时硬件错误或不是由事务内部逻辑产生的软件错误时。重启的事务被看成是一个新事务。

    2. 杀死(kill)事务。通常是由于事务内部逻辑造成的错误，只有重写应用程序才能改正，或者由于输入错误，或所需数据在数据库中没有找到。

---
## 事务隔离性

- 多个事务并发执行时可能违背隔离性。即使都正确执行，数据库的一致性也可能被破坏。

- 数据库必须控制事务之间的交互，以防止他们破坏数据库的一致性。系统通过 `并发控制机制`(concurrency-control scheme)来实现。

- 假设有两个事务
```
T1:
read(A);
A = A - 50;
write(A);
read(B);
B = B + 50;
write(B);

T2:
read(A);
temp = A * 0.1;
A = A - temp;
write(A);
read(B);
B = B + temp;
write(B);
```

- 如果串行执行，事务T1和T2执行后A+B之和维持不变。
- 类似的，如果T2先执行，T1再执行，A+B之和也依旧不变。(但是最终值不一样)

- 前面所描述的执行顺序称为 `调度` (schedule)。他们表示指令在系统中执行的时间顺序。

- 一组事务的一个调度必须包含这一组事务的全部指令。并且必须保持指令在各个事务中出现的顺序。

- 串行(serial)的调度是指属于同一事务的指令在调度中紧挨在一起。如：
```
T1              T2
read(A);
A = A - 50;
write(A);
read(B);
B = B + 50;
write(B);   
                read(A);
                temp = A * 0.1;
                A = A - temp;
                write(A);
                read(B);
                B = B + temp;
                write(B);
```

- 当数据库并发执行多个事务时，调度不一定是串行的。可能一个事务执行一小段时间，然后切换上下文，另一个事务执行一小段时间。

- 假如多个事务并发执行，就有可能导致最后出现不一致状态。如：事务B读取了A，这时候切换到事务A写入了A，这时候就会导致不一致性。
```
```

- 保证所执行的任何调度都能使数据库处于一致状态，这是数据库的任务。完成这个任务的是 `并发控制`(concurrency-control)部件。

- 在并发执行中，保证所执行的任何调度的效果和串行调度效果一致，这种调度称为可串行化(serializable) 调度。

---

## 可串行化
- 我们只考虑两种操作：`read` 和 `write` 。

- 本节主要讨论 `冲突可串行化` (conflict serializability)的形式。

- 考虑一个调度，其中含有分别属于I和J的两条连续指令i和j, i != j。
    - 如果I和J引用不同的数据项，则交换没有影响。

- 若I和J引用相同的数据项Q，则需要考虑4种情况:
    1. I J都是read(Q)，这个无关紧要。

    2. I=read(Q) J=write(Q)，若I先于J，则i不会读取到j写入的数据，否则会读取到，次序是重要的。

    3. I=write，J=read，和2类似。

    4. I = write， J = write。两条都是write的话，先后会决定下一条read读取的值。

- 因此，只有两者都是read才是无关紧要的。

- 考虑如下调度：
```
T1          T2
read(A)
write(A)
            read(A)
            write(A)
read(B)
write(B)
            read(B)
            write(B)
```

- T1和T2的writeA和T2的readA是冲突的。而访问不同数据项的指令则不冲突。

- 设I和J是调度S的两条连续指令，若I和J属于不同的事物且不冲突，则可以交换I和J的顺序得到一个新的调度S'。S和S'等价。

- 如果调度S可以通过一系列非冲突指令交换转换成S'，我们称S和S'是 `冲突等价`(conflict equivalent)的。

- 若一个调度S与一个串行调度冲突等价，则称调度S是冲突可串行化的。

- 为确定一个调度是否冲突可串行化，有一个简单有效的方法：

    - 设S是一个调度，由S构造一个有向图，称为优先图(precedence graph)。该图由两部分组成G=(V, E)，V是顶点集，E是边集，顶点集由所有参与调度的事物组成，边集由满足下列三个条件之一的边Ti->Tj组成
        1. 在Tj执行read(Q)之前，Ti执行write(Q)。
        
        2. 在Tj执行write(Q)之前，Ti执行read(Q)。

        3. 在Tj执行write(Q)之前，Ti执行write(Q)。
    
    - 结论：write之前所有对该数据的操作都要画边，read则只画write的。
    ```
    T1          T2
    read(A)
    write(A)
                read(A)
                write(A)
    read(B)
    write(B)
                read(B)
                write(B)
    ```

    - 设T1的四个指令为T11-T14 T2的四个指令为T21-T24，则其优先图如下：
    ```
    T11 -> T22
    T12 -> T21
    T12 -> T22

    T13 -> T24
    T14 -> T23
    T14 -> T24
    ```

    - 如果优先图中存在边Ti->Tj，则在任何等价于S的串行调度S'中，Ti必出现在Tj之前。

    - 如果调度S的优先图有环，则调度S是非冲突可串行化的，如果无环，则是冲突可串行化的。

    